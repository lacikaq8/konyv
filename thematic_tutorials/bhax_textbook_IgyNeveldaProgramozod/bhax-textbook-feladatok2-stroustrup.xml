<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Stroustrup!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>

    <section>
        <title>JDK osztályok</title>
        <para>
            Írjunk olyan Boost C++ programot (indulj ki például a fénykardból) amely kilistázza a JDK összes
            osztályát (miután kicsomagoltuk az src.zip állományt, arra ráengedve)!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            <emphasis role="strong">Tanulságok, tapasztalatok, magyarázat...</emphasis>
        </para>
        <caution>
            <title><emphasis role='red'>Program használata</emphasis></title>
            <para>
                <programlisting>
                    sudo apt-get install libboost-all-dev
                    sudo apt-get install qtdeclarative5-dev
                    qmake JavaClassCounter.pro
                    make
                    ./JavaClassCounter /path/to/src
                </programlisting>
                Vagy telepítsd a Qt Creator-t, és abba betöltve a *.pro fájlt, működni fog.
            </para>
        </caution>
        <para>
            A Boost egy kifejezetten C++hoz használható eszközkönyvtár. Használata egyszerű mivel csak include-álni kell a megfelelő header file-okat és a fordító magának megtalája a szükséges függvényeket, osztályokat. 
            A Boost.Filesystem és a Boost.Regex könyvtárakat fogjuk használni a feladat során. Filesystem azért lesz fontos számunkra, hogy a megadott mappában lévő fájlokat el tudjuk érni, Regex meg a kiterjesztés szűrésénél fog szerepet játszani. 
        </para>
        <para>
            A forrás az alábbiakat tartalmazza.
            <programlisting language="c++"><![CDATA[
                int iterator(boost::filesystem::path p){
                    int osztalyok_szama = 0;
                    boost::regex expr{"(.*\\.java)"};
                
                    for (const boost::filesystem::directory_entry& x : boost::filesystem::recursive_directory_iterator(p)){
                
                        if(boost::regex_match(x.path().string(), expr) && boost::filesystem::is_regular_file(x.path())){
                            std::cout << ++osztalyok_szama << std::endl;
                            std::cout << "    " << x.path() << '\n';
                        }
                    }
                    return osztalyok_szama;
                }]]>
            </programlisting>
            Az <function>iterator</function> függvény feladata, hogy kiszámolja a Java osztályok számát. Ehhez paraméterként kap egy 
            <function>boost::filesystem::path</function> típusú objektumot, mely tartalmazza a elérési útját a <function>src</function>-nek.
            A <function>osztalyok_szama</function> változóban tároljuk el a megtalált osztályok számát. Az <function>expr</function> objektum
            egy reguláris kifejezést tartalmaz, azokat a fájlokat vizsgálja, amik <function>.java</function>-ra végződnek. Majd a 
            <function>for</function> ciklus segítségével bejárjuk az <function>src</function> mappát. Ehhez a <function>recursive_directory_iterator</function>
            -t használjuk, melynek segítségével az almappákat is be tudjuk járni.
            Csak akkor növeljük a megtalált osztályok számát, ha illeszkedik a fájl neve a 
            <function>expr</function> kifejezésünkre, és maga a fájl egy hagyományos fájl, nem pedig mappa. A ciklus végeztével visszaadjuk a talált osztályok számát. 
        </para>
        <para>
            <programlisting language="c++"><![CDATA[
                int main(int argc, char *argv[])
                {
                    QCoreApplication a(argc, argv);
                
                    if (argc < 2)
                    {
                        std::cout << "Usage: tut3 path\n";
                        return 1;
                    }
                
                    boost::filesystem::path p (argv[1]);
                
                    try
                    {
                        int osztalyok_szama = iterator(p);
                        std::cout << "Java JDK osztályok száma " << osztalyok_szama << std::endl;
                    }
                
                    catch (const boost::filesystem::filesystem_error& ex)
                    {
                        std::cout << ex.what() << '\n';
                    }
                
                
                    return a.exec();
                }]]>
            </programlisting>
            A <function>main</function> függvényben pedig <function>p</function> objektumban eltároljuk az átadott útvonalt. Majd meghívjuk a 
            korábban tárgyalt <function>iterator</function> függvényt, és kiíratjuk a Java JDK osztályok számát terminálba.
        </para>
    </section>        

    <section>
        <title>Másoló-mozgató szemantika</title>
        <para>
            Kódcsipeteken (copy és move ctor és assign) keresztül vesd össze a C++11 másoló és a mozgató
            szemantikáját, a mozgató konstruktort alapozd a mozgató értékadásra!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            <emphasis role="strong">Tanulságok, tapasztalatok, magyarázat...</emphasis>
        </para>
        <para>
            Érdemes említést tenni arról, hogy mikor is hívódik meg a konstruktor, és az értékadás. 
            <programlisting language="c++">
                LZWBinFa binFa = binFa_regi; //konstruktor (másoló)
                LZWBinFa binFa2;
                binFa2 = binFa_regi; //értékadás (másoló)
            </programlisting>
            Szóval a lényeg az, hogy amikor az objektum létrehozásakor adunk értéket, akkor a mozgató/másoló konstruktor hívódik meg, viszont ha inicializált objektumnak adunk meg új értéket, akkor pedig a másoló/mozgató értékadás.
        </para>
        <para>
            A továbbiakban a konstruktort fogjuk vizsgálni. Mivel konstruktorról beszélünk, ezért a neve megegyezik az
            osztály nevével. A vezérlés akkor adódik át erre a konstruktorra, ha magával megegyező típusú referenciát adunk át.
            <programlisting language="c++"><![CDATA[
                LZWBinFa::LZWBinFa (const LZWBinFa & forras){
                    std::cout << "Copy ctor" << std::endl;
                    gyoker = new Csomopont('/');
                    gyoker->ujEgyesGyermek(masol(forras.gyoker->egyesGyermek(), forras.fa));
                    gyoker->ujNullasGyermek(masol(forras.gyoker->nullasGyermek(), forras.fa));
                    if (forras.fa == forras.gyoker){
                        fa = gyoker;
                    }
                }
                ]]>
            </programlisting>
            Látható, hogy ez a konstruktor egy <function>LZWBinFa</function> konstans refernciát vár paraméterként. Mivel ilyenkor nem hívódik meg az
            alap konstruktor, emiatt a <function>gyoker</function> pointerünknek értéket kell adni, különben memóriacímzési hibát kaphatunk. Ha ezzel 
            kész vagyunk, akkor létre kell hozni a gyökértől kiindulva az egyes gyermekeket, ezért van szükség a <function>ujEgyesGyermek</function>
            és <function>ujNullasGyermek</function> függvényekre. Mivel egy már elkészített fából indulunk ki, ezért annak a mintájára készítjük el a 
            gyermekeket. Ebben a <function>masol</function> függvény van segítségünkre. Ennek két paramétere van, az egyik a forrás gyökerének a 
            gyermeke, a másik pedig a forrás fa mutatója, mivel azt is szeretnénk átmásolni, hogy a fa mutató éppen hol áll az eredeti fában. 
            <programlisting language="c++"><![CDATA[
                Csomopont* LZWBinFa::masol (Csomopont* elem, Csomopont* regi_fa){
                    Csomopont* ujelem = nullptr;
                
                    if (elem != nullptr){
                        ujelem = new Csomopont (elem->getBetu());
                
                        ujelem -> ujEgyesGyermek(masol(elem->egyesGyermek(), regi_fa));
                        ujelem -> ujNullasGyermek(masol(elem->nullasGyermek(), regi_fa));
                
                        if (regi_fa == elem){
                            fa = ujelem;
                        }
                    }
                
                    return ujelem;
                }]]>
            </programlisting>
            A <function>masol</function> egy <function>Csomopont</function> mutatót ad vissza. Első lépésben létrehozzuk a később átadni kívánt 
            csomópontot. Majd ellenőrizzük, hogy az eredeti fa csomópontjának van-e értéke, vagy null pointer. Utóbbi esetben szimplán visszaadunk 
            egy null pointert. Ellenkező esetben a <function>ujelem</function> pointernek átadunk egy az eredeti csomópont alapján inicializált 
            csomóponthoz tartotó memóriacímet. Ezután újra meghívjuk a <function>masol</function> függvényt annak érdekében, hogy elkészítsük az 
            <function>ujelem</function> gyermekeit. Ezt addig folytatjuk, ameddig az eredeti fa végére nem érünk. Abban az esetben, ha a régi 
            fához tartozó fa mutató a <function>masol</function> függvénynek átadott elemre mutat, akkor az új fánk fa mutatóját ezen elem 
            alapján létrehozott csomópontra állítjuk. Végezetül pedig visszatérünk a csomóponttal. Ahhoz, hogy a fa mutatót a 
            <function>gyoker</function>-re is állíthassuk, a másoló konstruktorban is ellenőrizzük, hogy hova mutatat az eredeti fa fa mutatója. 
        </para>
        <para>
            Most, hogy megismerkedtünk a másoló konstruktorral, nézzük át röviden a másoló értékadást. Ezt is a <function>masol</function> függvényre
            alapozzuk.
            <programlisting language="c++"><![CDATA[
                LZWBinFa & LZWBinFa::operator= (const LZWBinFa & forras){
                    std::cout << "Copy assaignement" << std::endl;
                
                    gyoker->ujEgyesGyermek(masol(forras.gyoker->egyesGyermek(), forras.fa));
                    gyoker->ujNullasGyermek(masol(forras.gyoker->nullasGyermek(), forras.fa));
                
                    if (forras.fa == forras.gyoker){
                        fa = gyoker;
                    }
                    return *this;
                }]]>
            </programlisting>
            Lényegében egy operátor túlterhelésről van szó. Szemantikailag különbség a konstruktorhoz képest, hogy a másoló értékadásnak van visszatérési értéke,
            jelen esetben <function>LZWBinFa</function> referencia. Ennek megfelelően visszaadunk egy mutatót arról az objektumról, amely az egyenlőség 
            bal oldalán volt. Ezen kívül a már ismert eljárást követjük.
        </para>
        <para>
            A C++11 másoló szemantikájának megismerése után folytassuk a mozgató szemantikával, azon belül is a mozgató konstruktorral. A mozgató konstruktor 
            paraméteréül egy jobbértékreferenciát vár. Ezt jelöli a dupla <![CDATA[&]]>. A feladat szerint a mozgató értékadásra kell alapoznunk.
            <programlisting language="c++"><![CDATA[
                LZWBinFa::LZWBinFa (LZWBinFa&& forras)
                {
                    std::cout<<"Move ctor\n";
                    gyoker = nullptr;
                    *this = std::move(forras); //ezzel kényszerítjük ki, hogy a mozgató értékadást használja

                }
            ]]>
            </programlisting>
            Az alapkoncepciója az a mozgató értékadásra alapozásnak, hogy lényegében felcseréljük a két fa <function>gyoker</function> mutatójának értékét.
            Ennek érdekében az újonan létrehozni kívánt fa gyökerét null mutatóvá tesszük, majd meghívjuk a mozgató értékadást. Ehhez a <function>std::move</function>
            függvényyre van szükségünk, amely bemenetéül kapott paramétert jobbértékrefernciává alakítja. Mivel a <function>this</function> egy már inicializát objektumot
            jelöl, ezért nem a mozgató konstruktor, hanem a mozgató értékadás hívódik meg.
            <programlisting language="c++"><![CDATA[
                LZWBinFa& LZWBinFa::operator= (LZWBinFa&& forras)
                {
                    std::cout<<"Move assignment ctor\n";
                    std::swap(gyoker, forras.gyoker);
                    return *this;
                }
                ]]>
            </programlisting>
            A mozgató értékadás feladata a már korábban említett érték csere, melyet a <function>std::swap</function> valósít meg. Mivel a 
            megcserélődik a <function>gyoker</function> és a <function>forras.gyoker</function> által mutatott tárterület, ezért a mozgatás teljes egészében 
            megvalósul. Hiszen a <function>gyoker</function> egy null mutató, emiatt a csere után a <function>forras.gyoker</function> is null mutató lesz, 
            vagyis az eredeti fa "törlődött". Természetesen ez nem szószerint igaz, hiszen csak egy másik pointeren keresztül hivatkozunk a már korábban a 
            memóriában lefoglalt, és tárolt fára. 
        </para>
    </section>
    
    <section>
        <title>Hibásan implementált RSA törése</title>
        <para>
            Készítsünk betű gyakoriság alapú törést egy hibásan implementált RSA kódoló:
            <link xlink:href="https://arato.inf.unideb.hu/batfai.norbert/UDPROG/deprecated/Prog2_3.pdf">https://arato.inf.unideb.hu/batfai.norbert/UDPROG/deprecated/Prog2_3.pdf (71-73 fólia)</link> által
            készített titkos szövegen.
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            <emphasis role="strong">Tanulságok, tapasztalatok, magyarázat...</emphasis>
        </para>
        <para>
            Az RSA kódolást Ron <emphasis role="strong">R</emphasis>ivest, Adi <emphasis role="strong">S</emphasis>hamir és Len <emphasis role="strong">A</emphasis>dleman
            fejlesztette ki 1976-ben. Ez egy nyílt kulcsú tikosító algoritmus, mely a moduláris számelméleten és a prímszámelméleten alapul. A titkosításhoz 
            szükség van egy publikus és egy privát kulcsra, a nyílt kulccsal lehet kódolni a szövegünket, de csak a privát kóddal lehet dekódolni. 
        </para>
        <para>
            Maga az algoritmus a következő:
            <orderedlist numeration="lowerroman">
                <listitem>
                <para>Választani kell tetszőleges nagy prímet, <emphasis role="strong">p</emphasis>-t és <emphasis role="strong">q</emphasis>-t.</para>
                </listitem>
                <listitem>
                <para>Ki kell számolni az <emphasis role="strong">N = p*q</emphasis>-t, melynél <emphasis role="strong">N</emphasis> jelöli a 
                modulusát a nyílt és a titkos kulcsnak.</para>
                </listitem>
                <listitem>
                <para>Euler-féle fi függvényérték kiszámítása, melynek képlete a következő: <emphasis role="strong">fi(N) = (p-1)(q-1)</emphasis></para>
                </listitem>
                <listitem>
                <para>Kell találni egy olyan <emphasis role="strong">e</emphasis> számot, amely 1-nél nagyobb és fi(N)-nél kisebb. Emellett fontos, hogy
                <emphasis role="strong">e</emphasis>-nek és <emphasis role="strong">fi(N)</emphasis>-nek a legnagyobb közös osztólya 1 legyen.
                Az <emphasis role="strong">e</emphasis> lesz a nyilvános kucs kitevője, ezért nyilvánossaá tesszük.</para>
                </listitem>
                <listitem>
                    <para>
                        A privát kulcshoz is kell találni egy <emphasis role="strong">d</emphasis> kitevőt, mely esetén teljesül, hogy 
                        <emphasis role="strong">d*e</emphasis> <emphasis role="strong">fi(N)</emphasis> osztva 1 maradékot ad. Mivel ez a 
                        titkos kulcsnak a kitevője, ezért ezt is titkosítjuk. 
                    </para>
                </listitem>
            </orderedlist>
        </para>
        <para>
            A linkelt diásorban ezt az algoritmust megvalósító program forrását találjuk. Nézzük át, hogy mit is tartalmaznak ezek:
            <programlisting language="java"><![CDATA[
    class KulcsPar {

        java.math.BigInteger d, e, m;
        
        public KulcsPar() {
            int meretBitekben = 700 * (int) (java.lang.Math.log((double) 10) 
                    / java.lang.Math.log((double) 2));
            
            java.math.BigInteger p =
                    new java.math.BigInteger(meretBitekben, 100, new java.util.Random());
            java.math.BigInteger q =
                    new java.math.BigInteger(meretBitekben, 100, new java.util.Random());
        
            m = p.multiply(q);
            
            java.math.BigInteger z = p.subtract(java.math.BigInteger.ONE).
                    multiply(q.subtract(java.math.BigInteger.ONE));
            
            do {
                
                do {
                    d = new java.math.BigInteger(meretBitekben, new java.util.Random());
                } while (d.equals(java.math.BigInteger.ONE));
            
            } while (!z.gcd(d).equals(java.math.BigInteger.ONE));
            
            e = d.modInverse(z);
        
        }
        
    }]]>
            </programlisting>
            A <classname>Kulcspar</classname> osztály feladaata a fentebb leírt algoritmus megvalósítása. Ahhoz, hogy kellően nagy prímszámokat 
            találhassunk, a Java BigInteger osztályát használjuk. Ez lehetővé teszi, hogy sokkal nagyobb értékekkel számolhassunk, mint 
            bármelyik primitív adattípussal. Az egyszerűség kedvéért az algoritmus betűit használja a program is, kivéve az <emphasis role="strong">N
            </emphasis> betűt, melyet a forrásban <emphasis role="strong">m</emphasis> jelöl. 
            <programlisting language="java"><![CDATA[
            public class RSAPelda {

                public static void main(String[] args){
                    
                    KulcsPar jSzereplo = new KulcsPar();
                    
                    String tisztaSzoveg = "Hello, Vilag!";
                    
                    //kódol
                    byte[] buffer = tisztaSzoveg.getBytes();
                    java.math.BigInteger[] titkos = new java.math.BigInteger[buffer.length];
                    
                    for (int i = 0; i < titkos.length; ++i){
                        titkos[i] = new java.math.BigInteger(new byte[] {buffer[i]});
                        titkos[i] = titkos[i].modPow(jSzereplo.e, jSzereplo.m);
                    }
                    
                    //dekódol
                    for (int i = 0; i < titkos.length; ++i){
                        titkos[i] = titkos[i].modPow(jSzereplo.d, jSzereplo.m);
                        buffer[i] = titkos[i].byteValue();
                    }
                    
                    System.out.println(new String (buffer));
                }
                
            }]]>
            </programlisting>
            Az <classname>RSAPelda</classname> osztály végzi el a bemeneti szövegen a tikosítást és a dekódolást a <classname>KulcsPar</classname> osztály által generált 
            publikus és privát kulcsok alapján. A szöveg tikosítása úgy zajlik, hogy a <function>titkos</function> tömbben eltároljuk a bemenet adott eleméhez
            tartozó bytokat, majd a <function>modPow</function> függvény segítségével vesszük a <function>titkos[i]</function> érékenek a 
            <emphasis role="strong">e</emphasis>-edik hatványát modulo <emphasis role="strong">m</emphasis>. A dekódolás során ugyanezt a folyamatot hajtjuk végre, csak 
            <emphasis role="strong">d</emphasis>-edik hatványát vesszük az adott <function>titkos[i]</function>-nek. 
        </para>
        <para>
            Azután, hogy megismertük az eredetei programot, lássuk annak átalakított (elronott) verzióját. Az első probléma, hogy az eredeti nem karakterenként végzi a kódolást. Tehát az
            módosítani kell a kódon az alábbiak szerint.
            <programlisting language="java"><![CDATA[
                PrintWriter writer = new PrintWriter("output.txt");
                for (int idx = 0; idx < tisztaSzoveg.length(); ++idx) {
                    Character tisztaszoveg = tisztaSzoveg.charAt(idx);
                    tisztaszoveg = Character.toLowerCase(tisztaszoveg);
                    byte[] buffer = tisztaszoveg.toString().getBytes();
                    java.math.BigInteger[] titkos = new java.math.BigInteger[buffer.length];
                    byte[] output = new byte[buffer.length];
        
                    for (int i = 0; i < titkos.length; ++i) {
                        titkos[i] = new java.math.BigInteger(new byte[]{buffer[i]});
                        titkos[i] = titkos[i].modPow(jSzereplo.e, jSzereplo.m);
                        output[i] = titkos[i].byteValue();
                        writer.print(titkos[i]);
                    }
                    writer.println();
                }
                writer.close();        
            ]]></programlisting>
            A <classname>PrintWriter</classname> osztályt fogjuk használni a fájlbaíráshoz. Előnye a <classname>FileWriter</classname> osztályhoz képest, hogy képesek vagyunk
            átalakításnél a fájlba írni <classname>BigInteger</classname> típusú objektumokat. A karakterenkéntui kódolás, ahogy már megszokhattuk, abból áll, hogy a 
            bemeneten egy <function>for</function> ciklus segítségével végigmegyünk a <varname>tisztaSzoveg</varname>-en. A <function>charAt</function> függvény segítségével
            minden i. indexnél lévő karaktert tudjuk visszaadni, melyet eltráolunk lokális változóban, majd kisbetűsítünk a <function>tolowerCase</function> függvénnyel. 
            Erre azért van szükség, hogy könnyebben tudjuk dekódolni a szöveget. Majd a karaktert bájtsorozattá alakítjuk, végül a már korábban látott módon az RSA algoritmussal
            kódoljuk, az eredményt pedig kiírjuk egy fájlba.
            <programlisting language="java"><![CDATA[
                BufferedReader inputStream = new BufferedReader(new FileReader("output.txt"));
                int lines = 0;
                String line[] = new String[100000];
                while ((line[lines] = inputStream.readLine()) != null) {
                    lines++;
                }
                inputStream.close();        
            ]]></programlisting>
            Következő lépésként a korábban kiírt titkosított sorokat visszaolvassuk egy <classname>String</classname> tömbbe.
            Hogy az egyes karakterek titkosított alakját, és gyakoriságát könnyen tudjuk kezelni, ezért bevezetünk egy új osztályt, melynek 
            neve <classname>Karakterek</classname> lesz.
            <programlisting language="java"><![CDATA[
                class Karakterek {

                    private String encrypted;
                    private char karakter = ' ';
                    private int gyakorisag = 0;
                
                    public Karakterek(String str, char k) {
                        encrypted = str;
                        karakter = k;
                    }
                
                    public Karakterek(String str) {
                        encrypted = str;
                    }
                
                    public void setEncrypted(String str) {
                        encrypted = str;
                    }
                
                    public String getEncrypted() {
                        return encrypted;
                    }
                
                    public void setKarakter(char k) {
                        karakter = k;
                    }
                
                    public char getKarakter() {
                        return karakter;
                    }
                
                    public void increment() {
                        gyakorisag += 1;
                    }
                
                    public int getGyak() {
                        return gyakorisag;
                    }
                }]]>                
            </programlisting>
            Ezután a beolvasott sorokat el kell tároli <classname>Karakterek</classname> típusú objektumokba. Ennek érdekében létrehozunk egy tömböt, melybe csak akkor rakunk új karaktert, ha még
            nem létezik, ellenkező esetben az <function>increment</function> függvény segítségével növeljük az adott karakter gyakoriságát. Ezt írja le a következő kódrészlet.
            <programlisting language="java"><![CDATA[
                    Karakterek kar[] = new Karakterek[1000];
                    boolean found;
                    kar[0] = new Karakterek(line[0]);
                    int count = 1;
                    for (int i = 1; i < lines; i++) {
                        found = false;
                        for (int j = 0; j < count; j++) {
                            if (kar[j].getEncrypted().equals(line[i])) {
                                kar[j].increment();
                                found = true;
                                break;
                            }
                        }
                        if (!found) {
                            kar[count] = new Karakterek(line[i]);
                            count++;
                        }
                    }]]>
            </programlisting>
            Ha elkészítettük a tömböt, akkor ezt az elemek gyakorisága szerint sorba kell rendezni. Erre azért lesz szükség, mivel a statisztikai karaktergyakoriság alapján 
            fogjuk ezeket a titkosított elemeket heylettesíteni normál karakterekkel. A sorba rendezés a következőképpen néz ki:
            <programlisting language="java"><![CDATA[
                    for (int i = 0; i < count; i++) {
                        for (int j = i + 1; j < count; j++) {
                            if (kar[i].getGyak() < kar[j].getGyak()) {
                                Karakterek x = kar[i];
                                kar[i] = kar[j];
                                kar[j] = x;
                            }
                        }
                    }]]>
            </programlisting>
            Ahhoz, hogy a megtudjuk a statisztikai gyakoriságát az egyes karaktereknek éredmes ellátogatni a következő weboldalra:
            <link xlink:href="https://mdickens.me/typing/letter_frequency.html">https://mdickens.me/typing/letter_frequency.html</link>.
            Ezalapján elkészítjük a <filename>gyakorisag.txt</filename> fájlt, melynek minden egyes sorában egy karakter van. Ha ezt 
            elkészítettük, akkor már csak be kell olvasni a tartalmát.
            <programlisting language="java"><![CDATA[
                    FileReader f = new FileReader("gyakorisag.txt");
                    char[] karakter = new char[70];
                    int karCount = 0;
                    int k;
                    while ((k = f.read()) != -1) {
                        if ((char) k != '\n') {
                            karakter[karCount] = (char) k;
                            karCount++;
                        }
                    }
                    f.close();]]>           
            </programlisting>
            Az egyes karaktereket szintén egy tömbbe gyűjtjük össze, mely eleve a karakterekhez tartozó gyakoriság alapján lesz (csökkenően) rendezve. Ezután az a 
            feladatunk, hogy a korábban létrehozott <varname>kar</varname> tömb elemeit kicseréljük a beolvasott karakterekre. 
            <programlisting language="java"><![CDATA[
                    for (int i = 0; i < count; i++) {
                        kar[i].setKarakter(karakter[i]);
                    }]]>            
            </programlisting>
            Végezetül pedig elvégezzük a dekódolást, ami valószínűleg nem fog tökéletes eredményt adni. Ezt orvolandóan, el lehet készíteni a 
            bemeneti szövegünkhöz tartózó karaktergyakoriságot, de mivel a kódolt szöveg előzetes ismerete törésnél nem valószínű, ezért ezzel
            most nem élünk.
                
        </para>
    </section>        
        

    <section>
        <title>Változó argumentumszámú ctor</title>
        <para>
            Készítsünk olyan példát, amely egy képet tesz az alábbi projekt Perceptron osztályának bemenetére
            és a Perceptron ne egy értéket, hanem egy ugyanakkora méretű „képet” adjon vissza. (Lásd még a 4
            hét/Perceptron osztály feladatot is.)
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            <emphasis role="strong">Tanulságok, tapasztalatok, magyarázat...</emphasis>
        </para>
        <para>
            Ebben a fejezetben azzal ismerkedünk meg, hogyan lehet változó argumentumszámú konstruktort készíteni. Szintatktikailag 
            C++-ban a <function>...</function> karaktersorozat tudatja a fordítóval, hogy bármely paramétere lehet a konstruktornak, függvénynek.
            Ahhoz, hogy elérjük az összes paramétert a <function>cstdarg</function> header-re lesz szükségünk. Lássuk, hogyan néz ki a konstruktor:
            <programlisting language="c++"><![CDATA[
                Perceptron ( int nof, ... )
                {
                    n_layers = nof;
            
                    units = new double*[n_layers];
                    n_units = new int[n_layers];
            
                    va_list vap;
            
                    va_start ( vap, nof );
            
                    for ( int i {0}; i < n_layers; ++i )
                    {
                        n_units[i] = va_arg ( vap, int );
            
                        if ( i )
                            units[i] = new double [n_units[i]];
                    }
            
                    va_end ( vap );

                        ...
                        ]]>
            </programlisting>
            A <function>Perceptron</function> osztály konstruktorában egy megnevezett paraméter van, a <function>nof</function>. A maradék paraméterek eléréshez
            a deklaráljuk a <function>vap</function> <function>va_list</function> típusú változót, melyben a változó paramétereket tároljuk. Értékét a 
            <function>va_start</function> inicializálja. A <function>nof</function> azt adja meg, hogy hány paramétert adtunk meg. Ez két paramétert kér, egy <function>va_list</function>-et melybe betölti az argumentumokat, és 
            egy argumentumot, ahonnan kezdve betöltse az attribútumokat. A <function>va_arg</function> makro az aktuális <function>int</function> típusú
            paramétert adja vissza. Előnye, hogy minden meghívása módosítja a <function>vap</function> tartalmát oly módon, hogy a korábban visszaadott
            értéket követő értéket adja vissza. Tehát segítségével be tudjuk járni a paraméterlistát. A <function>va_end</function> pedig végrehajtaj a 
            megfelelő műveleteket, hogy többet ne tudjuk használni az argumentum listát. Összegezve a <function>va_start</function> segítségével 
            beolvassuk egy <function>va_list</function>-be a paramétereket, a <function>va_arg</function> segítségével kiolvassuk, és a <function>va_end</function> pedig 
            törli a paraméterlistát.
        </para>
        <para>
            Az előző fejezetben már használtuk a <function>Perceptron</function> osztályt. Ebben a fejezetben kisebb módosítást hajtunk végre 
            a működésében. A feladatban leírtak szerint nem egy értéket fog visszaadni, hanem egy vektort, aminek a mérete megegyezik a bemeneti kép
            méretével. A vektorban lévő elemekkel pedig manipuláljuk az eredeti képet, és elmentjük <filename>output.png</filename> néven.
        </para>
        <para>
            Lássuk, hogy milyen módosításokkal érhető el, hogy a egy képet kapjunk vissza. Az első lépés, hogy amikor példányosítunk egy 
            <function>Perceptron</function> típusú objektumot, akkor az utolsó paraméternek nem 1-et, hanem <function>size</function> értéket kell adnunk.
            <programlisting language="c++">
                Perceptron* p = new Perceptron (3, size, 256, size);
            </programlisting>
            Ezután a <function>Perceptron</function> osztályban meg kell oldanunk, hogy ezt megfelelően kezeljük, mivel alapból arra van kialakítva, hogy az 
            utolsó paraméter 1.
            <programlisting><![CDATA[
                std::vector< double > operator() ( double image [] )
                {
                    std::cout << "std" << std::endl;
                    units[0] = image;

                    for ( int i {1}; i < n_layers; ++i )
                    {

                        #ifdef CUDA_PRCPS

                        cuda_layer ( i, n_units, units, weights );

                        #else

                        #pragma omp parallel for
                        for ( int j = 0; j < n_units[i]; ++j )
                        {
                            units[i][j] = 0.0;

                            for ( int k = 0; k < n_units[i-1]; ++k )
                            {
                                units[i][j] += weights[i-1][j][k] * units[i-1][k];
                            }

                            units[i][j] = sigmoid ( units[i][j] );

                        }

                        #endif

                    }

                    std::vector< double > result_vector;
            
                    for (int i = 0; i < units[n_layers - 1]; ++i){
                            result_vector.push_back(sigmoid( units[n_layers - 1][i]));
                    }
                    return result_vector;
                }
            ]]>
            </programlisting>
            A <function>operator()</function> túlterhelés során egy vektort készítünk, és azt adjuk vissza. A túlterhelés vége  fontos, ahol a 
            <function>result_vector</function>-ba betöltjük a <function>sigmoid</function> függvény által kiszámított értékeket.
            Végezetül pedig a <function>main</function> függvényben a vektor értékei alapján módosítjuk az eredeti kép pixeleihez tartozó
            zöld értékeket.
            <programlisting language="c++"><![CDATA[

                        ...

                std::vector< double > value = (*p) (image);

                for (int i = 0; i<png_image.get_width(); ++i)
                    for (int j = 0; j<png_image.get_height(); ++j){
                        png_image[i][j].green = value[i*png_image.get_width() + j];
            
                }
            
                png_image.write("output.png");
            
                    ...]]>

            </programlisting>
            A <function>png_image</function> <function>write</function> tagfüggvénye segítségével pedig kiírjuk a módosított képet a 
            háttértárba.
        </para>
    </section>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        

    <section>
        <title>Összefoglaló</title>
        <para>
            Az előző 4 feladat egyikéről írj egy 1 oldalas bemutató „esszé" szöveget!
        </para>
        <para>
            <emphasis role="strong">A mozgató és másoló konstruktor</emphasis>
        </para>
        <para>
            A C++ objektum oreintált nyelv, vagyis lehetőséget biztosít a polimorfizmusra, az egységbezárást, és az adatrejtést. Definiálhatunk benne 
            osztályokat, melyek olyan tagfüggvénnyel rendelkező struktúráknak lehet nevezni, természetesen kibővítve az objektum orientáltság alapelveivel.
            Amikor egy osztályt példányosítunk, akkor az osztály konstruktora hívódik meg. Ha nem definiálunk konstruktort, akkor a fordító az alapértelmezett
            konstruktort használja. A konstruktorok olyan függvények, melyeknek feladata az objektum inicializálása. Vagyis ebben szoktunk a 
            az egyes tagváltozóknak értéket adni, bizonyos tagfüggvényeket meghívni, melyek szükséegese az objektum alapjának elkészítéséhez. Egy másik
            szembetűnő tulajdonsága a konstruktoroknak, hogy a nevük megegyezik az osztály nevével. A konstruktor ellentéte a destruktor, mely az objektum 
            törlésével együtt hívódik meg, és felszabadítja a már nem használt memóriaterületeket. Egy jól megírt C++ programban viszont nem elég ennek a 
            kettőnek a megléte, szükség van még másoló és mozgató konstruktorokra.
        </para>
        <para>
            A másoló és mozgató konstruktorok segítségével szintén objektumok inicializálását hajthatjuk végre, viszont egy másik azonos osztályú objektum
            alapján. Ha nem szeretnénk megírni ezeket, akkor a legegyszerűbb, ha letiltjuk használatukat, vagyis privát taggá tesszük őket. Erre azért van szükség,
            mert ha nem tiltjuk le őket, akkor a fordító az alapértelmezett másoló/mozgató konstruktort hívja meg, ami váratlan eredményekhez vezethet, kiszámíthatatlanná
            teszi a program működését. 
        </para>
        <para>
            A másoló konstruktor, ahogy a nevében is benne van egy objektumot másol le, és az alapján készít egy másikat. Onnan lehet felismerni, hogy 
            paraméterként mindig az őt magábafoglaló osztállyal azonos osztályú objektumrefenciát vár. Két fajta másolásról beszélhetünk: sekély és mély 
            másolás. A sekély másolás lényege, hogy csak létrehozunk egy másik mutatót, ami a paraméterként megadott onjektumra mutat. Ennek implementálása a 
            legegszerűbb, viszont használata problémákat okozhat. A legfőbb hátrány eme megoldási módnak, hogy közös a memóriaterület, tehát ha az egyiket
            módosítjuk, akkor az a másikr is kifejti hatását. Tehát ez nem egy igazi másolat, nevezhetnénk alias-nak. A mély másolás ezzel szemben egy különálló 
            onjektumot hoz létre, mely megegyezik a paraméterül kapott elemmel, viszont külön memóriacímen. Sekély társához képest implementálása összetettebb,
            viszont magabiztos használata jobb C++ programozóvá tesz.
        </para>
        <para>
            A 2. feladatban megvalósított másoló konstruktor a mély másolást implementálja. Tehát a forrásként kapott LZW fát bejárjuk, és 
            minden elemének a másolatát elkészítjük a konstruálandó fában is. Ennek következtében lesz két külön fánk a meóriában, külön 
            gyökér és fa mutatóval. Binárisfa bejárások közül létezik preorder, postorder és inorder. Ezek közül bármelyiket használhatjuk, mindegyik a 
            megfelelő eredményhez vezet. A mi programunk a postorder bejárást alkalmazza, vagyis elsőnek dolgozzuk fel a gyemekeket, majd gyökeret.
        </para>
        <para>
            A mozgató konstruktor a többi konstruktorhoz megfelelően egy inicializálást hajt végre, a másoláshoz hasonlóan ez is egy másik 
            objektumra alapul. A különbség annyi, hogy a míg a másolásnál a másolásban részt vevő objektumok megmaradnak, addig a 
            mozgatásnál a forrás objektum megszűnik, pontosabban nem determináns állapotba kerül. A mozgató konstruktor arról ismerszik meg, hogy a 
            paramétere egy jobbérték referencia. A jobbérték refernciát a <![CDATA[&&]]> jelöli. Annak érdekében, hogy ez a konstruktor hívódjon meg, a 
            <function>std::move</function> függvényt kell meghívni. Gyakori tévedés, köszönhetően ennek a függvénynek a félreérthető nevének, hogy 
            mozgatást hajt végre. Valójában a paraméteréül kapott objektum jobbérték refernciájával tér vissza.
        </para>
        <para>
            Az LZWBinFa programunkban maga a mozgató konstruktor a mozgató értékadásra van alapozva. Az alap koncepció az, hogy az inicializálni kívánt 
            fa gyökerét null mutatóvá tesszük, majd megcseréljük a forrás és a cél fa gyökér mutatójának értékét, ezzel megvalósítva a mozgatást. Ezt
            úgy érjük el, hogy a mozgató konstruktoron keresztül meghívjuk a mozgató értékadást. Fontos látni, hogy mikor hívódik meg a konstruktor és mikor 
            az értékadás. Ha egy még nem inicializát objektumot szeretnénk másolással, mozgatással inicializálni, akkor a konstruktor hívódik. Ezzel szemben
            egy már inicializát objektumba szeretnénk másolni, mozgatni, akkor már az értékadás hajtódik végre. Ennek tudatában szerepel a 
            mozgató konstruktorban a következő sor:
            <programlisting language="c++">
                *this = std::move(forras);
            </programlisting>
            Szóval meghívódik a mozgató értékadás, ahol a pointer értékek cseréjét hajtjuk végre. Ehhez a <function>std::swap</function> függvényt 
            használjuk. Természetesen lehetne saját cserét is írni, ebben a könyvben több megoldást adtunk erre, de összességében elmondható, hogy
            érdemes a már előre implementált függvényeket, metódusokat használni. 
        </para>
        <para>
            Összegezve a leírtakat, a másoló és mozgató szemantika a C++ nyelvben kiemelt szerepet játszik. Magabiztos használatuk elsajátítása 
            nélkülözhetetlen a megbízható programok készítéséhez. 
        </para>
    </section> 
    <section>
        <title>EPAM: It's gone. Or is it?</title>
        <para>Adott a következő osztály:</para>
        <para>
            <programlisting language="java"><![CDATA[
public class BugousStuffProducer {
private final Writer writer;
public BugousStuffProducer(String outputFileName) throws
IOException {
writer = new FileWriter(outputFileName);
}
public void writeStuff() throws IOException {
writer.write("Stuff");
}
@Override
public void finalize() throws IOException {
writer.close();
}
}]]></programlisting>
Mutass példát arra az esetre, amikor előfordulhat, hogy bár a program futása során meghívtuk a
writeStuff() metódust, a fájl, amibe írtunk még is üres.
        </para>
        <para></para>
    </section>       

    <section>
        <title>EPAM: Kind of equal</title>
        <para>
            Adott az alábbi kódrészlet.
        <programlisting language="java"><![CDATA[
// Given
String first = "...";
String second = "...";
String third = "...";
// When
var firstMatchesSecondWithEquals = first.equals(second);
var firstMatchesSecondWithEqualToOperator = first == second;
var firstMatchesThirdWithEquals = first.equals(third);
var firstMatchesThirdWithEqualToOperator = first == third;
}]]></programlisting> 
Változtasd meg a String third = "..."; sort úgy, hogy a
firstMatchesSecondWithEquals, firstMatchesSecondWithEqualToOperator,
firstMatchesThirdWithEquals értéke true, a
firstMatchesThirdWithEqualToOperator értéke pedig false legyen. Magyarázd
meg, mi történik a háttérben.
        </para>
    </section>

    <section>
        <title>EPAM: Java GC</title>
        <para>Mutasd be nagy vonalakban hogyan működik Java-ban a GC (Garbage Collector). Lehetséges az
OutOfMemoryError kezelése, ha igen milyen esetekben? Források: <link xlink:href="https://medium.com/@hasithalgamge/seven-types-of-java-garbage-collectors-6297a1418e82">https://medium.com/@hasithalgamge/seven-types-of-java-garbage-collectors-6297a1418e82</link> , <link xlink:href="https://stackoverflow.com/questions/2679330/catching-java-lang-outofmemoryerror">https://stackoverflow.com/questions/2679330/catching-java-lang-outofmemoryerror</link></para>
    <para></para>
    </section>


</chapter>                
